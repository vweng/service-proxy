<!--
	Routing Configuration
	
	Here you can configure routing rules for Membrane ESB. It
	contains some proxy definitions to show how to setup routing. Please make sure to
	remove these rules before you put the router into production. More sample
	configurations you can find in the examples directory of the Membrane ESB distribution.
	
	A quick start guide is available at: 
	http://membrane-soa.org/esb-doc/current/overview/ .
	
	See the reference at:
	http://membrane-soa.org/esb-doc/current/configuration/reference/ .  
-->
<spring:beans xmlns="http://membrane-soa.org/proxies/1/"
	xmlns:spring="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:web="http://membrane-soa.org/war/1/"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
					    http://membrane-soa.org/proxies/1/ http://membrane-soa.org/schemas/proxies-1.xsd
					    http://membrane-soa.org/war/1/ http://membrane-soa.org/schemas/war-1.xsd">
      	 
	<!--
		This is the configuration using Application Server embedding (see web.xml).
		It uses the Web Containers's connectors (see configuration of the web
		server) and configured paths (see web.xml).
	-->

	<limitedMemoryExchangeStore id="memoryExchangeStore"  maxSize="8192000" />

	<spring:bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
		<spring:property name="placeholderPrefix" value="$p{" />
    	<spring:property name="placeholderSuffix" value="}" />
	</spring:bean>
  
	<groovy id="api-request-setup">
		def ua = exc.request.header.getFirstValue("User-Agent")
		def ct = exc.request.header.getFirstValue("Content-Type")
		def ex = exc.request.header.getFirstValue("Expect")
		println "[CC-API] ==== URI: ${exc.request.uri}, Method: ${exc.request.method}, Content-Type:${ct}, Expect:${ex}, Agent:${ua}"
		
		if (ua &amp;&amp; (ua.contains("MSIE 8")||ua.contains("MSIE 7"))) {
			// workaround for IE8 (which sometimes also use MSIE 7 as user agent),
			// as it doesn't support CORS without setting content-type to text/plain. 
			// and we need it to be x-www-form-urlencoded otherwise webMethods won't work.
			exc.request.header.removeFields("Content-Type")
			exc.request.header.add("Content-Type", "application/x-www-form-urlencoded")
		}
		
		if (ex &amp;&amp; ex.contains("100-Continue")) {
			exc.request.header.removeFields("Expect") // remove Expect: 100-Continue header injected by WAS8.0, otherwise wM flops
		}
		
		exc.request.header.removeFields("Authorization") // remove any authorization header so as to allow wM login to work
		exc.request.header.setAuthorization("cc_api", System.getProperty("ccapi.password"));
	</groovy>

	
    <groovy id="api-response-setup">
		def ach = exc.response.header.getFirstValue("Access-Control-Allow-Origin");
		if (!ach) { // multiple values could result in disabled CORS, must have at most 1.
			exc.response.header.add("Access-Control-Allow-Origin", "*.toronto.ca"); 
		}					
    </groovy>

    <groovy id="prep-input-validation">
    	// To get the validator tag to perform JSON schema validation, we need to extract query parameters and set it to http body.
    	def isValid = true;
		def jsonKey = exc.getProperty("X-JSON-KEY");
		if (!jsonKey) jsonKey = "json=";  // default if not found, note it must not include regex reserved letters or patterns

		def parts = exc.request.uri.split('\\?', 2); // limit max splits to 2
		def queryStr = parts.length == 2?parts[1]:"";
		if (exc.request.method==Request.METHOD_POST &amp;&amp; queryStr.indexOf(jsonKey) &lt; 0) {
			def bodyStr = exc.request.getBodyAsStringDecoded();
			exc.setProperty("X-ORI-BODY", bodyStr); // keep original body stored
			queryStr += "&amp;"+ (bodyStr.startsWith(jsonKey)?bodyStr: (jsonKey+bodyStr));
		}
		// verify if there is more than one json= param in querystr, if so report error
		if ((queryStr =~ /${jsonKey}/).count &gt; 1) {
			isValid = false;
		} else {
			def params = queryStr.split("&amp;");
			for (int i = 0; i &lt; params.length; i++) {
				if (params[i].startsWith(jsonKey)) {
					def jsonValue = params[i].substring(jsonKey.length());
					if (exc.request.method != Request.METHOD_POST) {
						exc.setProperty("X-ORI-METHOD", exc.request.method); // keep method stored
						exc.request.method="VALIDATE"; // change method so that validator tag can work.
					}
					exc.request.setBodyContent(URLDecoder.decode(jsonValue).getBytes(exc.request.getCharset()));
					continue;
				} else if (params[i].startsWith('callback=')) {
					if (params[i] ==~ /^callback=\w{1,50}$/ ) {  
						// jQuery callback is 41 chars: jQuery111009626693264581263_1427919355740
						continue
					} else {
						isValid = false;
						break;
					}
					continue
				} else if (params[i].startsWith('_=')) {
					if (params[i] ==~ /^_=\d{1,15}$/) { // jQuery time seed is 13 digits
						continue;
					} else {
						isValid = false;
						break;
					}
				} else if (!params[i]) { // allows url without json= parameter
					continue
				} else {
					println "[CC-API Warning] Invalid paramters detected ==> ${params}"
					isValid = false;  // Note: Calling ABORT from within a loop only breaks, it will not quit the groovy interceptor.
					break;
				}
			}
		}
		
		if (!isValid) {
			Response.badRequest().contentType("application/json").body('{"error":"Input validation failed"}').build() // must be the last statement, otherwise won't respond
		}	
    </groovy>

    <groovy id="restore-after-validation">
    	// after validation, we need to restore the http body and method to original
		def xom = exc.getProperty("X-ORI-METHOD");
		if (xom) { // was altered, need to change back
			exc.request.method = xom;
			exc.request.setBodyContent(new byte[0]); // must clear the body otherwise process may stuck upon the next call
		} else if (exc.getProperty("X-ORI-BODY")) {
			exc.request.setBodyContent(exc.getProperty("X-ORI-BODY").getBytes(exc.request.getCharset())); // restore the body content
		}
	</groovy>
  
	<router hotDeploy="false" exchangeStore="memoryExchangeStore">
		<web:servletTransport id="transport">
			<limit maxBodyLength="1024000" />
			<headerFilter>
				<exclude>Connection</exclude>
				<exclude>Content-Encoding</exclude>
				<exclude>Content-Length</exclude>
				<exclude>Content-MD5</exclude>
				<exclude>Server</exclude>
				<exclude>Transfer-Encoding</exclude>
			</headerFilter>
			<ruleMatching />
			<exchangeStore name="memoryExchangeStore" />
			<dispatching />
			<reverseProxying />
			<userFeature />
			<httpClient>
				<httpClientConfig maxRetries="2"/>
			</httpClient>
		</web:servletTransport>
	
		
		<!-- Sets up the Administration Web Interface "^/admin.*" or disable it with "[\\b\\B]". -->
	    <serviceProxy>
	    	<path isRegExp="true">$p{ccapi.adminConsole}</path>

			<adminConsole readOnly="true" />
	    </serviceProxy>
	      	
	      	
		<serviceProxy name="UtilityAccount">
			<path isRegExp="true">^/svcaccount_v1/UtilityAccount/(validate(\?.*|$)|\d{9}-\d{9}-\d{2}(\?.*|$))</path>
			<request>
				<rewriter>
					<map do="rewrite" from="^/svcaccount_v1/UtilityAccount/validate(\?.*|$)" 
						to="/rest/COTIdmaAccountAccessAPI/REST/svcaccount_v1/UtilityAccount/validate$1" />
					<map do="rewrite" from="^/svcaccount_v1/UtilityAccount/(\d{9}-\d{9}-\d{2}(\?.*|$))" 
						to="/rest/COTIdmaAccountAccessAPI/REST/svcaccount_v1/UtilityAccount/$1" />
				</rewriter>
				<groovy>					
					if (exc.request.method==Request.METHOD_POST||exc.request.method==Request.METHOD_GET) {
						exc.setProperty("X-JSON-KEY", "validateRequest=");
					} else {
						Response.badRequest().contentType("application/json").body('{"error":"Invalid action"}').build()  // must be the last statement, otherwise won't respond
					}
				</groovy>
				
				<spring:ref bean="api-request-setup" />
				<spring:ref bean="prep-input-validation" />
				<validator jsonSchema="schemas/UtilityAccount.json"  failureHandler="log" />
				<spring:ref bean="restore-after-validation" />
			</request> 
			<response>
				<spring:ref bean="api-response-setup" />
			</response>

			<target host="$p{ccapi.targetHost}" port="5679">
				<ssl>
					<truststore location="truststore.jks" password="cc_api" />
				</ssl>
			</target>
		</serviceProxy>

		<serviceProxy name="ParkingTicket">
			<path isRegExp="true">^/svcaccount_v1/ParkingTicket/view\?(.*)</path>

			<request>
				<rewriter>
					<map do="rewrite" from="^/svcaccount_v1/ParkingTicket/view\?(.*)" 
						to="/rest/COTIdmaAccountAccessAPI/REST/svcaccount_v1/ParkingTicket/view?$1" />
				</rewriter>
				<groovy>
					if (exc.request.method!=Request.METHOD_GET) {
						Response.badRequest().contentType("application/json").body('{"error":"Invalid action"}').build() // must be the last statement, otherwise won't respond
					}
				</groovy>

				<spring:ref bean="api-request-setup" />
				<spring:ref bean="prep-input-validation" />
				<validator jsonSchema="schemas/ParkingTicket.json"  failureHandler="log" />
				<spring:ref bean="restore-after-validation" />
			</request> 
			<response>
				<spring:ref bean="api-response-setup" />
			</response>

			<target host="$p{ccapi.targetHost}" port="5679">
				<ssl>
					<truststore location="truststore.jks" password="cc_api" />
				</ssl>
			</target>
		</serviceProxy>

		<serviceProxy name="PropertyTax">
			<path isRegExp="true">^/svcaccount_v1/PropertyTax/view\?(.*)</path>

			<request>
				<rewriter>
					<map do="rewrite" from="^/svcaccount_v1/PropertyTax/view\?(.*)" 
						to="/rest/COTIdmaAccountAccessAPI/REST/svcaccount_v1/PropertyTax/view?$1" />
				</rewriter>
				<groovy>
					if (exc.request.method!=Request.METHOD_GET) {
						Response.badRequest().contentType("application/json").body('{"error":"Invalid action"}').build() // must be the last statement, otherwise won't respond
					}
				</groovy>

				<spring:ref bean="api-request-setup" />
				<spring:ref bean="prep-input-validation" />
				<validator jsonSchema="schemas/PropertyTax.json"  failureHandler="log" />
				<spring:ref bean="restore-after-validation" />
			</request> 
			<response>
				<spring:ref bean="api-response-setup" />
			</response>

			<target host="$p{ccapi.targetHost}" port="5679">
				<ssl>
					<truststore location="truststore.jks" password="cc_api" />
				</ssl>
			</target>
		</serviceProxy>

		<serviceProxy name="WaterAccount">
			<path isRegExp="true">^/svcaccount_v1/WaterAccount/(validate|accountdetails|consumption|groupconsumption|weatherdata)(\?.*|$)</path>
			<request>
				<rewriter>
					<map do="rewrite" from="^/svcaccount_v1/WaterAccount/(validate|accountdetails|consumption|groupconsumption|weatherdata)(\?.*|$)" 
										to="/rest/COTIdmaAccountAccessAPI/REST/svcaccount_v1/WaterAccount/$1$2" />                                                                            
				</rewriter>
				<groovy>                                                                             
					if (exc.request.method==Request.METHOD_POST||exc.request.method==Request.METHOD_GET) {
						// good
					} else {
						Response.badRequest().contentType("application/json").body('{"error":"Invalid action"}').build() // must be the last statement, otherwise won't respond
					}
				</groovy>

				<spring:ref bean="api-request-setup" />
				<spring:ref bean="prep-input-validation" />
				<validator jsonSchema="schemas/WaterAccount.json"  failureHandler="log" />
				<spring:ref bean="restore-after-validation" />
			</request> 
			<response>
				<spring:ref bean="api-response-setup" />
			</response>

			<target host="$p{ccapi.targetHost}" port="5679">
				<ssl>
					<truststore location="truststore.jks" password="cc_api" />
				</ssl>
			</target>
		</serviceProxy>
	</router>

</spring:beans>
