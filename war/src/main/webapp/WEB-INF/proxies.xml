<!--
	Routing Configuration
	
	Here you can configure routing rules for Membrane ESB. It
	contains some proxy definitions to show how to setup routing. Please make sure to
	remove these rules before you put the router into production. More sample
	configurations you can find in the examples directory of the Membrane ESB distribution.
	
	A quick start guide is available at: 
	http://membrane-soa.org/esb-doc/current/overview/ .
	
	See the reference at:
	http://membrane-soa.org/esb-doc/current/configuration/reference/ .  
-->
<spring:beans xmlns="http://membrane-soa.org/proxies/1/"
	xmlns:spring="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:web="http://membrane-soa.org/war/1/"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
					    http://membrane-soa.org/proxies/1/ http://membrane-soa.org/schemas/proxies-1.xsd
					    http://membrane-soa.org/war/1/ http://membrane-soa.org/schemas/war-1.xsd">
      	 
	<!--
		This is the configuration using Application Server embedding (see web.xml).
		It uses the Web Containers's connectors (see configuration of the web
		server) and configured paths (see web.xml).
	-->

	<limitedMemoryExchangeStore id="memoryExchangeStore"  maxSize="8192000" />

	<spring:bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
		<spring:property name="placeholderPrefix" value="$p{" />
    	<spring:property name="placeholderSuffix" value="}" />
	</spring:bean>

	<groovy id="api-preflight">
		if (exc.request.method==Request.METHOD_OPTIONS) { // note that the preflight response may be cached by browser
			def requestHeaders = exc.request.header.getFirstValue('Access-Control-Request-Headers')
			Response.ok().header('Access-Control-Allow-Headers', requestHeaders?requestHeaders:'origin, content-type, accept')
						 .header('Access-Control-Allow-Methods', 'GET, POST') // cc-api only supports GET and POST so far
						 .build() // must be the last statement, otherwise won't respond
						 
		} else if (!exc.getProperty("X-ALLOW-METHODS").contains(exc.request.method) {
			Response.badRequest().contentType("application/json").body('{"error":"Invalid action method"}').build()  // must be the last statement, otherwise won't respond
		}
	</groovy>

	<groovy id="api-request-setup">
		def ua = exc.request.header.getFirstValue("User-Agent")
		def ct = exc.request.header.getFirstValue("Content-Type")
		def ex = exc.request.header.getFirstValue("Expect")
		println "[CC-API] ==== URI: ${exc.request.uri}, Method: ${exc.request.method}, Content-Type:${ct}, Expect:${ex}, Agent:${ua}"
		
		if (ua &amp;&amp; (ua.contains("MSIE 8")||ua.contains("MSIE 7"))) {
			// workaround for IE8 (which sometimes also use MSIE 7 as user agent),
			// as it doesn't support CORS without setting content-type to text/plain. 
			// and we need it to be x-www-form-urlencoded otherwise webMethods won't work.
			exc.request.header.removeFields("Content-Type")
			exc.request.header.add("Content-Type", "application/x-www-form-urlencoded")
		}
		
		if (ex) {
			exc.request.header.removeFields("Expect") // remove Expect: 100-Continue header injected by WAS8.0, otherwise wM flops
		}
		
		exc.request.header.removeFields("Authorization") // remove any authorization header so as to allow wM login to work
		exc.request.header.setAuthorization("cc_api", System.getProperty("ccapi.password"));
	</groovy>

	<groovy id="api-response-setup">
		def origin="https://secure.toronto.ca";
		def firstOrigin=exc.request.header?exc.request.header.getFirstValue("Origin"):null;
		if (firstOrigin)
			try {
				def netUrl = new URL(firstOrigin);
				if (netUrl.getHost().endsWith(".toronto.ca")) 
					origin = exc.request.header.getFirstValue("Origin");
			} catch (Exception e) {
				println "----- Failed to setup origin ${firstOrigin} with error: " + e.toString();
			}
		exc.response.header.removeFields("Access-Control-Allow-Origin")
		exc.response.header.add("Access-Control-Allow-Origin", origin);	
	</groovy>

    <groovy id="prep-input-validation">
    	// To get the validator tag to perform JSON schema validation, we need to extract query parameters and set it to http body.
    	def isValid = true;
		def jsonKey = exc.getProperty("X-JSON-KEY");
		if (!jsonKey) jsonKey = "json=";  // default if not found, note it must not include regex reserved letters or patterns

		def parts = exc.request.uri.split('\\?', 2); // limit max splits to 2
		def queryStr = parts.length == 2?parts[1]:"";
		if (exc.request.method==Request.METHOD_POST &amp;&amp; queryStr.indexOf(jsonKey) &lt; 0) {
			def bodyStr = exc.request.getBodyAsStringDecoded();
			exc.setProperty("X-ORI-BODY", bodyStr); // keep original body stored
			queryStr += "&amp;"+ (bodyStr.startsWith(jsonKey)?bodyStr: (jsonKey+bodyStr));
		}
		// verify if there is more than one json= param in querystr, if so report error
		if ((queryStr =~ /${jsonKey}/).count &gt; 1) {
			println "[CC-API Warning] Invalid jsonKey detected ==> ${jsonKey}"
			isValid = false;
		} else {
			def params = queryStr.split("&amp;");
			for (int i = 0; i &lt; params.length; i++) {
				if (params[i].startsWith(jsonKey)) {
					def jsonValue = params[i].substring(jsonKey.length());
					if (exc.request.method != Request.METHOD_POST) {
						exc.setProperty("X-ORI-METHOD", exc.request.method); // keep method stored
						exc.request.method="VALIDATE"; // change method so that validator tag can work.
					}
					exc.request.setBodyContent(URLDecoder.decode(jsonValue).getBytes(exc.request.getCharset()));
					continue;
				} else if (params[i].startsWith('callback=')) {
					if (params[i] ==~ /^callback=\w{1,50}$/ ) {  
						// jQuery callback is 41 chars: jQuery111009626693264581263_1427919355740
						continue
					} else {
						println "[CC-API Warning] Invalid callback param detected"
						isValid = false;
						break;
					}
					continue
				} else if (params[i].startsWith('_=')) {
					if (params[i] ==~ /^_=\d{1,15}$/) { // jQuery time seed is 13 digits
						continue;
					} else {
						println "[CC-API Warning] Invalid jQuery seed param detected"
						isValid = false;
						break;
					}
				} else if (!params[i]) { // allows url without json= parameter
					continue
				} else {
					println "[CC-API Warning] Invalid paramters detected ==> ${params}"
					isValid = false;  // Note: Calling ABORT from within a loop only breaks, it will not quit the groovy interceptor.
					break;
				}
			}
		}
		
		if (!isValid) {
			// Response.badRequest().contentType("application/json").body('{"error":"Input validation failed"}').build() // must be the last statement, otherwise won't respond
			ABORT // validate failure is equal to IOException, should log but NOT return due to security concern. 
			// Using ABORT here to make it matching the behavior when the JSON validator tag failed with JSONParseException, which is IOException
		}	
    </groovy>

    <groovy id="restore-after-validation">
    	// after validation, we need to restore the http body and method to original
		def xom = exc.getProperty("X-ORI-METHOD");
		if (xom) { // was altered, need to change back
			exc.request.method = xom;
			exc.request.setBodyContent(new byte[0]); // must clear the body otherwise process may stuck upon the next call
		} else if (exc.getProperty("X-ORI-BODY")) {
			exc.request.setBodyContent(exc.getProperty("X-ORI-BODY").getBytes(exc.request.getCharset())); // restore the body content
		}
	</groovy>
  
	<router hotDeploy="false" exchangeStore="memoryExchangeStore">
		<web:servletTransport id="transport">
			<limit maxBodyLength="1024000" />
			<headerFilter>
				<exclude>Connection</exclude>
				<exclude>Content-Encoding</exclude>
				<exclude>Content-Length</exclude>
				<exclude>Content-MD5</exclude>
				<exclude>Server</exclude>
				<exclude>Transfer-Encoding</exclude>
			</headerFilter>
			<ruleMatching />
			<exchangeStore name="memoryExchangeStore" />
			<dispatching />
			<reverseProxying />
			<userFeature />
			<httpClient>
				<httpClientConfig maxRetries="2"/>
			</httpClient>
		</web:servletTransport>
	
		
		<!-- Sets up the Administration Web Interface "^/admin.*" or disable it with "[\\b\\B]". -->
	    <serviceProxy>
	    	<path isRegExp="true">$p{ccapi.adminConsole}</path>

			<adminConsole readOnly="true" />
	    </serviceProxy>
	      	
	      	
		<serviceProxy name="UtilityAccount">
			<path isRegExp="true">^/svcaccount_v1/UtilityAccount/(validate(\?.*|$)|\d{9}-\d{9}-\d{2}(\?.*|$))</path>
			<request>
				<rewriter>
					<map do="rewrite" from="^/svcaccount_v1/UtilityAccount/validate(\?.*|$)" 
						to="/rest/COTIdmaAccountAccessAPI/REST/svcaccount_v1/UtilityAccount/validate$1" />
					<map do="rewrite" from="^/svcaccount_v1/UtilityAccount/(\d{9}-\d{9}-\d{2}(\?.*|$))" 
						to="/rest/COTIdmaAccountAccessAPI/REST/svcaccount_v1/UtilityAccount/$1" />
				</rewriter>

				<groovy>
					exc.setProperty("X-JSON-KEY", "validateRequest=") // for legacy compatibility as new APIs all use "json=" standard
					exc.setProperty("X-ALLOW-METHODS", Request.METHOD_GET+","+Request.METHOD_POST)
				</groovy>
				<spring:ref bean="api-preflight" />				
				<spring:ref bean="api-request-setup" />
				<spring:ref bean="prep-input-validation" />
				<validator jsonSchema="schemas/UtilityAccount.json"  failureHandler="log" />
				<spring:ref bean="restore-after-validation" />
			</request> 
			<response>
				<spring:ref bean="api-response-setup" />
			</response>

			<target host="$p{ccapi.targetHost}" port="5679">
				<ssl>
					
				</ssl>
			</target>
		</serviceProxy>

		<serviceProxy name="ParkingTicket">
			<path isRegExp="true">^/svcaccount_v1/ParkingTicket/view\?(.*)</path>

			<request>
				<rewriter>
					<map do="rewrite" from="^/svcaccount_v1/ParkingTicket/view\?(.*)" 
						to="/rest/COTIdmaAccountAccessAPI/REST/svcaccount_v1/ParkingTicket/view?$1" />
				</rewriter>
				
				<groovy>
					exc.setProperty("X-ALLOW-METHODS", Request.METHOD_GET)
				</groovy>
				<spring:ref bean="api-preflight" />
				<spring:ref bean="api-request-setup" />
				<spring:ref bean="prep-input-validation" />
				<validator jsonSchema="schemas/ParkingTicket.json"  failureHandler="log" />
				<spring:ref bean="restore-after-validation" />
			</request> 
			<response>
				<spring:ref bean="api-response-setup" />
			</response>

			<target host="$p{ccapi.targetHost}" port="5679">
				<ssl>
					
				</ssl>
			</target>
		</serviceProxy>

		<serviceProxy name="PropertyTax">
			<path isRegExp="true">^/svcaccount_v1/PropertyTax/view\?(.*)</path>

			<request>
				<rewriter>
					<map do="rewrite" from="^/svcaccount_v1/PropertyTax/view\?(.*)" 
						to="/rest/COTIdmaAccountAccessAPI/REST/svcaccount_v1/PropertyTax/view?$1" />
				</rewriter>
				
				<groovy>
					exc.setProperty("X-ALLOW-METHODS", Request.METHOD_GET)
				</groovy>
				<spring:ref bean="api-preflight" />
				<spring:ref bean="api-request-setup" />
				<spring:ref bean="prep-input-validation" />
				<validator jsonSchema="schemas/PropertyTax.json"  failureHandler="log" />
				<spring:ref bean="restore-after-validation" />
			</request> 
			<response>
				<spring:ref bean="api-response-setup" />
			</response>

			<target host="$p{ccapi.targetHost}" port="5679">
				<ssl>
					
				</ssl>
			</target>
		</serviceProxy>

		<serviceProxy name="WaterAccount">
			<path isRegExp="true">^/svcaccount_v1/WaterAccount/(validate|accountdetails|consumption|groupconsumption|weatherdata)(\?.*|$)</path>
			<request>
				<rewriter>
					<map do="rewrite" from="^/svcaccount_v1/WaterAccount/(validate|accountdetails|consumption|groupconsumption|weatherdata)(\?.*|$)" 
										to="/rest/COTIdmaAccountAccessAPI/REST/svcaccount_v1/WaterAccount/$1$2" />                                                                            
				</rewriter>
				
				<groovy>
					exc.setProperty("X-ALLOW-METHODS", Request.METHOD_GET+","+Request.METHOD_POST)
				</groovy>
				<spring:ref bean="api-preflight" />
				<spring:ref bean="api-request-setup" />
				<spring:ref bean="prep-input-validation" />
				<validator jsonSchema="schemas/WaterAccount.json"  failureHandler="log" />
				<spring:ref bean="restore-after-validation" />
			</request> 
			<response>
				<spring:ref bean="api-response-setup" />
			</response>

			<target host="$p{ccapi.targetHost}" port="5679">
				<ssl>
					
				</ssl>
			</target>
		</serviceProxy>
	</router>

</spring:beans>
